{"ast":null,"code":"// thanh tự động trượt\nconst initLevelSlider = () => {\n  const slider = document.getElementById('levelsSlider');\n  if (!slider) return;\n  const track = slider.querySelector('.levels-track');\n  const cards = track.querySelectorAll('.level-card-container');\n  const prevBtn = document.querySelector('.slider-prev');\n  const nextBtn = document.querySelector('.slider-next');\n\n  // Nếu không có đủ card, không thực hiện infinite scroll\n  if (cards.length < 2) return;\n\n  // Tạo slider vô hạn bằng cách sao chép card đầu tiên và cuối cùng\n  const firstCardClone = cards[0].cloneNode(true);\n  const lastCardClone = cards[cards.length - 1].cloneNode(true);\n  firstCardClone.classList.add('clone');\n  lastCardClone.classList.add('clone');\n\n  // Thêm clone vào đầu và cuối\n  track.appendChild(firstCardClone);\n  track.insertBefore(lastCardClone, cards[0]);\n\n  // Tính toán kích thước\n  let cardWidth = cards[0].offsetWidth;\n  let gap = parseInt(window.getComputedStyle(track).columnGap || '24');\n  let containerWidth = slider.offsetWidth;\n  let scrollAmount = cardWidth + gap; // Bắt đầu từ card thứ 2 (sau clone)\n\n  // Di chuyển đến vị trí bắt đầu (sau card clone)\n  track.style.transform = `translateX(-${scrollAmount}px)`;\n\n  // Các biến cho tự động cuộn\n  let autoScrollInterval;\n  const autoScrollDelay = 3000;\n  let isTransitioning = false;\n\n  // Bắt đầu tự động cuộn\n  const startAutoScroll = () => {\n    stopAutoScroll();\n    autoScrollInterval = setInterval(() => {\n      scrollNext(true);\n    }, autoScrollDelay);\n  };\n\n  // Dừng tự động cuộn\n  const stopAutoScroll = () => {\n    if (autoScrollInterval) {\n      clearInterval(autoScrollInterval);\n      autoScrollInterval = null;\n    }\n  };\n\n  // Xử lý sự kiện transitionend để tạo hiệu ứng vô hạn\n  const handleTransitionEnd = () => {\n    if (!isTransitioning) return;\n\n    // Xóa transition để nhảy ngay lập tức\n    track.style.transition = 'none';\n    const allCards = track.querySelectorAll('.level-card-container');\n    const cardsCount = allCards.length;\n\n    // Nếu đang ở card cuối (thực tế là clone đầu tiên), nhảy đến vị trí thực của card đầu\n    if (scrollAmount >= (cardsCount - 2) * (cardWidth + gap)) {\n      scrollAmount = cardWidth + gap;\n    }\n    // Nếu đang ở card đầu (thực tế là clone cuối cùng), nhảy đến vị trí thực của card cuối\n    else if (scrollAmount <= 0) {\n      scrollAmount = (cardsCount - 3) * (cardWidth + gap);\n    }\n    track.style.transform = `translateX(-${scrollAmount}px)`;\n\n    // Đợi một chút và thêm lại transition\n    setTimeout(() => {\n      track.style.transition = 'transform 0.5s ease';\n      isTransitioning = false;\n    }, 10);\n  };\n\n  // Thêm transition cho mượt\n  track.style.transition = 'transform 0.5s ease';\n  track.addEventListener('transitionend', handleTransitionEnd);\n\n  // Xử lý cập nhật khi thay đổi kích thước màn hình\n  const handleResize = () => {\n    cardWidth = cards[0].offsetWidth;\n    gap = parseInt(window.getComputedStyle(track).columnGap || '24');\n    containerWidth = slider.offsetWidth;\n\n    // Cập nhật vị trí\n    track.style.transition = 'none';\n    track.style.transform = `translateX(-${scrollAmount}px)`;\n\n    // Thêm lại transition sau khi cập nhật\n    setTimeout(() => {\n      track.style.transition = 'transform 0.5s ease';\n    }, 10);\n  };\n  window.addEventListener('resize', handleResize);\n\n  // Xử lý nút Previous\n  const scrollPrev = (isAuto = false) => {\n    if (isTransitioning && !isAuto) return;\n    isTransitioning = true;\n    scrollAmount -= cardWidth + gap;\n    track.style.transform = `translateX(-${scrollAmount}px)`;\n  };\n\n  // Xử lý nút Next\n  const scrollNext = (isAuto = false) => {\n    if (isTransitioning && !isAuto) return;\n    isTransitioning = true;\n    scrollAmount += cardWidth + gap;\n    track.style.transform = `translateX(-${scrollAmount}px)`;\n  };\n  prevBtn.addEventListener('click', () => {\n    stopAutoScroll();\n    scrollPrev();\n    startAutoScroll();\n  });\n  nextBtn.addEventListener('click', () => {\n    stopAutoScroll();\n    scrollNext();\n    startAutoScroll();\n  });\n\n  // Chức năng vuốt trên thiết bị cảm ứng\n  let isDragging = false;\n  let startPos = 0;\n  let currentTranslate = 0;\n  const dragStart = e => {\n    stopAutoScroll();\n    if (e.type === 'touchstart') {\n      startPos = e.touches[0].clientX;\n    }\n    isDragging = true;\n    currentTranslate = scrollAmount;\n  };\n  const drag = e => {\n    if (isDragging) {\n      const currentPosition = e.touches[0].clientX;\n      const diff = startPos - currentPosition;\n\n      // Áp dụng kéo\n      track.style.transition = 'none';\n      track.style.transform = `translateX(-${currentTranslate + diff}px)`;\n    }\n  };\n  const dragEnd = e => {\n    if (!isDragging) return;\n    isDragging = false;\n    const currentPosition = e.changedTouches[0].clientX;\n    const diff = startPos - currentPosition;\n\n    // Quyết định swipe direction\n    if (Math.abs(diff) > 50) {\n      // Min swipe distance\n      if (diff > 0) {\n        scrollNext();\n      } else {\n        scrollPrev();\n      }\n    } else {\n      // Không đủ khoảng cách, quay lại vị trí ban đầu\n      track.style.transition = 'transform 0.5s ease';\n      track.style.transform = `translateX(-${scrollAmount}px)`;\n    }\n    startAutoScroll();\n  };\n  track.addEventListener('touchstart', dragStart);\n  track.addEventListener('touchend', dragEnd);\n  track.addEventListener('touchmove', drag);\n\n  // Dừng tự động cuộn khi hover vào slider\n  slider.addEventListener('mouseenter', stopAutoScroll);\n  slider.addEventListener('mouseleave', startAutoScroll);\n\n  // Bắt đầu tự động cuộn\n  startAutoScroll();\n\n  // Return cleanup function\n  return () => {\n    window.removeEventListener('resize', handleResize);\n    prevBtn.removeEventListener('click', () => scrollPrev());\n    nextBtn.removeEventListener('click', () => scrollNext());\n    track.removeEventListener('touchstart', dragStart);\n    track.removeEventListener('touchend', dragEnd);\n    track.removeEventListener('touchmove', drag);\n    track.removeEventListener('transitionend', handleTransitionEnd);\n    slider.removeEventListener('mouseenter', stopAutoScroll);\n    slider.removeEventListener('mouseleave', startAutoScroll);\n    stopAutoScroll();\n  };\n};\nexport default initLevelSlider;","map":{"version":3,"names":["initLevelSlider","slider","document","getElementById","track","querySelector","cards","querySelectorAll","prevBtn","nextBtn","length","firstCardClone","cloneNode","lastCardClone","classList","add","appendChild","insertBefore","cardWidth","offsetWidth","gap","parseInt","window","getComputedStyle","columnGap","containerWidth","scrollAmount","style","transform","autoScrollInterval","autoScrollDelay","isTransitioning","startAutoScroll","stopAutoScroll","setInterval","scrollNext","clearInterval","handleTransitionEnd","transition","allCards","cardsCount","setTimeout","addEventListener","handleResize","scrollPrev","isAuto","isDragging","startPos","currentTranslate","dragStart","e","type","touches","clientX","drag","currentPosition","diff","dragEnd","changedTouches","Math","abs","removeEventListener"],"sources":["/Users/trunghieu/nihongo-master/nihongo-master/frontend/src/utils/levelSlider.js"],"sourcesContent":["// thanh tự động trượt\nconst initLevelSlider = () => {\n    const slider = document.getElementById('levelsSlider');\n    if (!slider) return;\n    \n    const track = slider.querySelector('.levels-track');\n    const cards = track.querySelectorAll('.level-card-container');\n    const prevBtn = document.querySelector('.slider-prev');\n    const nextBtn = document.querySelector('.slider-next');\n    \n    // Nếu không có đủ card, không thực hiện infinite scroll\n    if (cards.length < 2) return;\n    \n    // Tạo slider vô hạn bằng cách sao chép card đầu tiên và cuối cùng\n    const firstCardClone = cards[0].cloneNode(true);\n    const lastCardClone = cards[cards.length - 1].cloneNode(true);\n    \n    firstCardClone.classList.add('clone');\n    lastCardClone.classList.add('clone');\n    \n    // Thêm clone vào đầu và cuối\n    track.appendChild(firstCardClone);\n    track.insertBefore(lastCardClone, cards[0]);\n    \n    // Tính toán kích thước\n    let cardWidth = cards[0].offsetWidth;\n    let gap = parseInt(window.getComputedStyle(track).columnGap || '24');\n    let containerWidth = slider.offsetWidth;\n    let scrollAmount = cardWidth + gap; // Bắt đầu từ card thứ 2 (sau clone)\n    \n    // Di chuyển đến vị trí bắt đầu (sau card clone)\n    track.style.transform = `translateX(-${scrollAmount}px)`;\n    \n    // Các biến cho tự động cuộn\n    let autoScrollInterval;\n    const autoScrollDelay = 3000;\n    let isTransitioning = false;\n    \n    // Bắt đầu tự động cuộn\n    const startAutoScroll = () => {\n      stopAutoScroll();\n      \n      autoScrollInterval = setInterval(() => {\n        scrollNext(true);\n      }, autoScrollDelay);\n    };\n    \n    // Dừng tự động cuộn\n    const stopAutoScroll = () => {\n      if (autoScrollInterval) {\n        clearInterval(autoScrollInterval);\n        autoScrollInterval = null;\n      }\n    };\n    \n    // Xử lý sự kiện transitionend để tạo hiệu ứng vô hạn\n    const handleTransitionEnd = () => {\n      if (!isTransitioning) return;\n      \n      // Xóa transition để nhảy ngay lập tức\n      track.style.transition = 'none';\n      \n      const allCards = track.querySelectorAll('.level-card-container');\n      const cardsCount = allCards.length;\n      \n      // Nếu đang ở card cuối (thực tế là clone đầu tiên), nhảy đến vị trí thực của card đầu\n      if (scrollAmount >= (cardsCount - 2) * (cardWidth + gap)) {\n        scrollAmount = cardWidth + gap;\n      } \n      // Nếu đang ở card đầu (thực tế là clone cuối cùng), nhảy đến vị trí thực của card cuối\n      else if (scrollAmount <= 0) {\n        scrollAmount = (cardsCount - 3) * (cardWidth + gap);\n      }\n      \n      track.style.transform = `translateX(-${scrollAmount}px)`;\n      \n      // Đợi một chút và thêm lại transition\n      setTimeout(() => {\n        track.style.transition = 'transform 0.5s ease';\n        isTransitioning = false;\n      }, 10);\n    };\n    \n    // Thêm transition cho mượt\n    track.style.transition = 'transform 0.5s ease';\n    track.addEventListener('transitionend', handleTransitionEnd);\n    \n    // Xử lý cập nhật khi thay đổi kích thước màn hình\n    const handleResize = () => {\n      cardWidth = cards[0].offsetWidth;\n      gap = parseInt(window.getComputedStyle(track).columnGap || '24');\n      containerWidth = slider.offsetWidth;\n      \n      // Cập nhật vị trí\n      track.style.transition = 'none';\n      track.style.transform = `translateX(-${scrollAmount}px)`;\n      \n      // Thêm lại transition sau khi cập nhật\n      setTimeout(() => {\n        track.style.transition = 'transform 0.5s ease';\n      }, 10);\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Xử lý nút Previous\n    const scrollPrev = (isAuto = false) => {\n      if (isTransitioning && !isAuto) return;\n      isTransitioning = true;\n      \n      scrollAmount -= cardWidth + gap;\n      track.style.transform = `translateX(-${scrollAmount}px)`;\n    };\n    \n    // Xử lý nút Next\n    const scrollNext = (isAuto = false) => {\n      if (isTransitioning && !isAuto) return;\n      isTransitioning = true;\n      \n      scrollAmount += cardWidth + gap;\n      track.style.transform = `translateX(-${scrollAmount}px)`;\n    };\n    \n    prevBtn.addEventListener('click', () => {\n      stopAutoScroll();\n      scrollPrev();\n      startAutoScroll();\n    });\n    \n    nextBtn.addEventListener('click', () => {\n      stopAutoScroll();\n      scrollNext();\n      startAutoScroll();\n    });\n    \n    // Chức năng vuốt trên thiết bị cảm ứng\n    let isDragging = false;\n    let startPos = 0;\n    let currentTranslate = 0;\n    \n    const dragStart = (e) => {\n      stopAutoScroll();\n      \n      if (e.type === 'touchstart') {\n        startPos = e.touches[0].clientX;\n      }\n      isDragging = true;\n      currentTranslate = scrollAmount;\n    };\n    \n    const drag = (e) => {\n      if (isDragging) {\n        const currentPosition = e.touches[0].clientX;\n        const diff = startPos - currentPosition;\n        \n        // Áp dụng kéo\n        track.style.transition = 'none';\n        track.style.transform = `translateX(-${currentTranslate + diff}px)`;\n      }\n    };\n    \n    const dragEnd = (e) => {\n      if (!isDragging) return;\n      isDragging = false;\n      \n      const currentPosition = e.changedTouches[0].clientX;\n      const diff = startPos - currentPosition;\n      \n      // Quyết định swipe direction\n      if (Math.abs(diff) > 50) { // Min swipe distance\n        if (diff > 0) {\n          scrollNext();\n        } else {\n          scrollPrev();\n        }\n      } else {\n        // Không đủ khoảng cách, quay lại vị trí ban đầu\n        track.style.transition = 'transform 0.5s ease';\n        track.style.transform = `translateX(-${scrollAmount}px)`;\n      }\n      \n      startAutoScroll();\n    };\n    \n    track.addEventListener('touchstart', dragStart);\n    track.addEventListener('touchend', dragEnd);\n    track.addEventListener('touchmove', drag);\n    \n    // Dừng tự động cuộn khi hover vào slider\n    slider.addEventListener('mouseenter', stopAutoScroll);\n    slider.addEventListener('mouseleave', startAutoScroll);\n    \n    // Bắt đầu tự động cuộn\n    startAutoScroll();\n    \n    // Return cleanup function\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      prevBtn.removeEventListener('click', () => scrollPrev());\n      nextBtn.removeEventListener('click', () => scrollNext());\n      track.removeEventListener('touchstart', dragStart);\n      track.removeEventListener('touchend', dragEnd);\n      track.removeEventListener('touchmove', drag);\n      track.removeEventListener('transitionend', handleTransitionEnd);\n      slider.removeEventListener('mouseenter', stopAutoScroll);\n      slider.removeEventListener('mouseleave', startAutoScroll);\n      stopAutoScroll();\n    };\n  };\n  \n  export default initLevelSlider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}